#include "CodeGenerator.h"
#include "InterfaceDescription.h"

#include <algorithm>
#include <cctype>
#include <exception>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>

// Check if the string is all caps
bool all_caps(const std::string &s) {
    return std::none_of(s.begin(), s.end(), ::islower);
}

/**
 * Convert lowerCamelCase and UpperCamelCase strings to UPPER_WITH_UNDERSCORES
 */
static inline std::string CamelToUpper(const std::string &camelCase) {
    std::string str(1, tolower(camelCase[0]));

    // First place underscores between contiguous lower and upper case letters.
    // For example, `_LowerCamelCase` becomes `_Lower_Camel_Case`.
    for (auto it = camelCase.begin() + 1; it != camelCase.end(); ++it) {
        if (isupper(*it) && *(it-1) != '_' && islower(*(it-1))) {
            str += "_";
        }

        str += *it;
    }

    // then to uppercase
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
    return str;
}

/**
 * Returns the fully qualified name of the namespace in which a particular message struct was
 * encoded to.
 */
static inline std::string GetProtoMsgNsName(const InterfaceDescription::Method &m,
        const bool isResponse) {
    auto temp = m.getName();
    temp[0] = std::toupper(temp[0]);

    temp.append(isResponse ? "Response" : "Request");
    return std::string(CodeGenerator::kProtoNamespace) + "::" + temp;
}

/**
 * Returns the name of the stub class for the server, given the interface name.
 */
static inline std::string GetClassName(const std::shared_ptr<InterfaceDescription> &id) {
    auto temp = id->getName();
    temp[0] = std::toupper(temp[0]);

    return temp + "Server";
}
/**
 * Returns the name of the method for use in a stub class.
 */
static inline std::string GetMethodName(const InterfaceDescription::Method &m) {
    auto temp = m.getName();
    temp[0] = std::toupper(temp[0]);
    return temp;
}

/**
 * Returns the fully qualified name of the constant that contains the identifier of the given
 * method.
 */
static inline std::string GetMethodIdConst(const InterfaceDescription::Method &m) {
    auto temp = m.getName();
    temp = CamelToUpper(temp);
    return "rpc::_proto::messages::MESSAGE_ID_" + temp;
}

/**
 * Returns the name of the getter for the given argument.
 */
static inline std::string GetterNameFor(const InterfaceDescription::Argument &a) {
    auto temp = a.getName();
    temp[0] = std::toupper(temp[0]);
    return "get" + temp;
}
/**
 * Returns the name of the setter for the given argument.
 */
static inline std::string SetterNameFor(const InterfaceDescription::Argument &a) {
    auto temp = a.getName();
    temp[0] = std::toupper(temp[0]);
    return "set" + temp;
}



/**
 * Generate the C++ server stub for the interface.
 *
 * This implements the concrete wire message (de)serialization for incoming requests, as well as
 * the replies thereto. The implementer then simply subclasses this base stub, and implements the
 * relevant abstract methods that actually implement the behavior of the interface.
 */
void CodeGenerator::generateServerStub() {
    auto fileNameH = this->outDir / ("Server_" + this->interface->getName() + ".hpp");
    auto fileNameCpp = this->outDir / ("Server_" + this->interface->getName() + ".cpp");
    std::cout << "    * Server stub: " << fileNameCpp.string() << ", " << fileNameH.string()
              << std::endl;

    // generate the header first
    std::ofstream header(fileNameH.string(), std::ofstream::trunc);
    this->serverWriteInfoBlock(header);
    header << R"(#pragma once

#include <string>
#include <cstddef>
#include <cstdint>
#include <memory>
#include <span>
)" << std::endl;
    this->serverWriteHeader(header);

    // and then the implementation
    std::ofstream implementation(fileNameCpp.string(), std::ofstream::trunc);
    this->serverWriteInfoBlock(implementation);
    implementation << "#include \"" << fileNameH.filename().generic_string() << "\"" << std::endl
       << "#include \"" << this->protoFileName.filename().generic_string() << ".h\"" << std::endl
       << R"(
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <stdexcept>

#include <capnp/message.h>
#include <capnp/serialize.h>

using namespace rpc;
)";
    this->serverWriteImpl(implementation);
}

/**
 * Write the generic info block comment for the server stub.
 */
void CodeGenerator::serverWriteInfoBlock(std::ofstream &os) {
    os << R"(/*
 * This RPC server stub was autogenerated by idlc. DO NOT EDIT!)" << std::endl
    << " * Generated from " << this->interface->getSourceFilename() << " for interface "
       << this->interface->getName() << " at " << this->creationTimestamp << std::endl
       << " *" << R"(
 * You should subclass this implementation and define the required abstract methods to complete
 * implementing the interface. Note that there are several helper methods available to simplify
 * this task, or to retrieve more information about the caller.
 *
 * See the full RPC documentation for more details.
)"
       << " */" << std::endl;
}



/**
 * Writes the header for the server stub.
 *
 * This consists of a large fixed portion to define types and internal functions and helpers, as
 * well as two variable portions: one, defining the abstract methods that the implementation shall
 * provide, and two, the implementation of the deserialization of method parameters, and then
 * serialization of its response.
 */
void CodeGenerator::serverWriteHeader(std::ofstream &os) {
    // set up the starting of the class
    const auto className = GetClassName(this->interface);

    os << "namespace rpc {" << std::endl;
    /**
     * Define the RPC stream type; this is an abstract interface that defines how the rest of the
     * server stub receives and sends messages.
     *
     * Note that the IO stream instance owns the receive message data, and that it must remain
     * valid for as long as the stream is active. The transmit buffer is required to only be
     * valid for the duration of the `send()` call.
     */
    os << R"(#ifndef __RPC_RPCSTREAM_H
#define __RPC_RPCSTREAM_H
class RpcIoStream {
    public:
        virtual ~RpcIoStream() = default;

        virtual bool receive(std::span<std::byte> &outRxBuf, const bool block) = 0;
        virtual bool reply(const std::span<std::byte> &buf) = 0;
};
#endif

)";

    os << "class " << className << " {";

    /*
     * Define the types, including the MessageHeader, which is the structure we expect to receive
     * from whatever input/output stream we're provided.
     */
    os << R"(
    struct MessageHeader {
        enum Flags: uint32_t {
            Request                     = (1 << 0),
            Response                    = (1 << 1),
        };

        uint64_t type;
        Flags flags;
        uint32_t tag;

        std::byte payload[];
    };
    static_assert(!(offsetof(MessageHeader, payload) % sizeof(uintptr_t)),
        "message header's payload is not word aligned");
    )";

    // public methods
    os << R"(
    public:
        )" << className << R"((const std::shared_ptr<RpcIoStream> &stream);
        virtual ~)" << className << R"(();

        // Server's main loop; continuously read and handle messages.
        bool run(const bool block = true);
        // Process a single message.
        bool runOne(const bool block);
    )";

    // abstract methods to implement
    os << R"(
    // These are methods the implementation provides to complete implementation of the interface
    protected:
)";
    for(const auto &m : this->interface->getMethods()) {
        os << "        virtual ";
        this->serverWriteMethodDef(os, m, "impl");
        os << " = 0;" << std::endl;
    }

    // implementation details
    os << R"(
    // Helpers provided to subclasses for implementation of interface methods
    protected:
        constexpr inline auto &getIo() {
            return this->io;
        }

    // Implementation details; pretend this does not exist
    private:
        std::shared_ptr<RpcIoStream> io;
        size_t txBufSize{0};
        void *txBuf{nullptr};

        void _ensureTxBuf(const size_t);
        void _doSendReply(const MessageHeader &, const std::span<std::byte> &);

)";

    // autogenerated marshalling methods
    for(const auto &m : this->interface->getMethods()) {
        os << "        void _marshall" << GetMethodName(m)
           << "(const MessageHeader &, const std::span<std::byte> &payload)"
           << ";" << std::endl;
    }

    // close the class and namespace
    os << "}; // class " << className << std::endl
       << "} // namespace rpc" << std::endl;
}



/**
 * Writes the server stub implementation.
 */
void CodeGenerator::serverWriteImpl(std::ofstream &os) {
    const auto className = GetClassName(this->interface);
    os << "using Server = " << className << ';' << std::endl << std::endl;

    // run method
    os << R"(/**
 * Continuously processes messages until processing fails to receive another message.
 */
bool Server::run(const bool block) {
    bool cont;
    do {
        cont = this->runOne(block);
    } while(cont);
    return cont;
}

/**
 * Reads a single message from the RPC connection and attempts to process it.
 *
 * @throws If the received message is malformed.
 *
 * @return Whether a message was able to be received and processed.
 */
bool Server::runOne(const bool block) {
    // try to receive message
    std::span<std::byte> buf;
    if(!this->io->receive(buf, block)) return false;

    // get the message header and its payload
    if(buf.size() < sizeof(MessageHeader)) {
        throw std::runtime_error("received message too small");
    }
    const auto hdr = reinterpret_cast<const MessageHeader *>(buf.data());

    const auto payload = buf.subspan(offsetof(MessageHeader, payload));

    // then invoke the appropriate marshalling function
    switch(hdr->type) {
)";

    for(const auto &m : this->interface->getMethods()) {
        os << "        case " << GetMethodIdConst(m) << ':' << std::endl
           << "            this->_marshall" << GetMethodName(m) << "(*hdr, payload);"
           << std::endl
           << "            break;" << std::endl;
    }

    os << R"(    }
    return true;
}

)";

    // implementations of marshalling methods
    for(const auto &m : this->interface->getMethods()) {
        this->serverWriteMarshallMethod(os, m);
    }

    // built in helpers
    os << R"(

// Helper method to build and send a reply message
void Server::_doSendReply(const MessageHeader &inHdr, const std::span<std::byte> &payload) {
    const size_t len = sizeof(MessageHeader) + payload.size();
    this->_ensureTxBuf(len);

    auto hdr = reinterpret_cast<MessageHeader *>(this->txBuf);
    memset(hdr, 0, sizeof(*hdr));
    hdr->type = inHdr.type;
    hdr->flags = MessageHeader::Flags::Response;
    hdr->tag = inHdr.tag;

    memcpy(hdr->payload, payload.data(), payload.size());

    const std::span<std::byte> txBufSpan(reinterpret_cast<std::byte *>(this->txBuf), len);
    if(!this->io->reply(txBufSpan)) {
        throw std::runtime_error("Failed to send RPC reply");
    }
}

// Allocates an aligned transmit buffer of the given size
void Server::_ensureTxBuf(const size_t len) {
    if(len > this->txBufSize) {
        if(this->txBuf) {
            free(this->txBuf);
        }
        int err = posix_memalign(&this->txBuf, 16, len);
        if(err) {
            throw std::runtime_error("Failed to allocate RPC send buffer");
        }
        this->txBufSize = len;
    }
}
)";
}

/**
 * Writes the implementation of the method to marshall the specified method call.
 */
void CodeGenerator::serverWriteMarshallMethod(std::ofstream &os, const Method &m) {
    // start method
    os << R"(/*
 * Autogenerated marshalling method for ')" << m.getName() << R"(' (id $)" << std::hex << m.getIdentifier() << R"()
 * Have )" << m.getParameters().size() << R"( parameter(s), )" << m.getReturns().size() << R"( return(s); method is )" << (m.isAsync() ? "async" : "sync") << R"(
 */
)"
       << "void Server::_marshall" << GetMethodName(m) << "(const MessageHeader &hdr, const std::span<std::byte> &payload) {";

    // deserialize the request
    os << R"(
    kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
            payload.size() / sizeof(capnp::word));
    capnp::FlatArrayMessageReader reader(message);
    auto request = reader.getRoot<)" << GetProtoMsgNsName(m, false) << R"(>();
)";

    for(const auto &a : m.getParameters()) {
        if(a.isBuiltinType()) {
            if(a.isPrimitiveType()) {
                os << "    const auto dec_" << a.getName() << " = request." << GetterNameFor(a)
                   << "();" << std::endl;
            }
            // strings and blobs have special handling to convert them to desired C++ types
            else {
                auto lowerName = a.getTypeName();
                std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);

                if(lowerName == "string") {
                    os << "    const std::string dec_" << a.getName() << "(request."
                       << GetterNameFor(a) << "());" << std::endl;
                } else if(lowerName == "blob") {
                    // this dropping the const ptr is absolutely disgusting
                    os << "    const auto dec_temp_" << a.getName() << " = request."
                        << GetterNameFor(a) << "();" << std::endl;
                    os << "    const std::span<std::byte> dec_" << a.getName()
                       << "(reinterpret_cast<std::byte *>(const_cast<unsigned char *>(dec_temp_"
                       << a.getName() << ".begin())), dec_temp_" << a.getName() << ".size());"
                       << std::endl;
                } else {
                    throw std::runtime_error("Unknown non-primitive builtin type");
                }
            }
        }
        // non-builtin types aren't yet supported
        else {
            throw std::runtime_error("Deserializing non-builtin type not yet supported");
        }
    }

    // invoke implementation method
    os << std::endl;
    if(!m.isAsync() && !m.getReturns().empty()) {
        os << "    auto retVal = ";
    } else {
        os << "    ";
    }
    os << "this->impl" << GetMethodName(m) << '(';

    for(size_t i = 0; i < m.getParameters().size(); i++) {
        const auto &a = m.getParameters()[i];
        os << "dec_" << a.getName();

        if(i != m.getParameters().size()-1) {
            os << ", ";
        }
    }

    os << ");" << std::endl;

    // handle the reply
    if(!m.isAsync()) {
        this->serverWriteMarshallMethodReply(os, m);
    }

    // finish method
    os << '}' << std::endl;
}
/**
 * Writes marshalling code for sending the reply of the invoked method.
 *
 * XXX: This currently only handles the case of either zero or a single return value.
 */
void CodeGenerator::serverWriteMarshallMethodReply(std::ofstream &os, const Method &m) {
    // set up builder
    os << R"(
    capnp::MallocMessageBuilder replyBuilder;
    auto reply = replyBuilder.initRoot<)" << GetProtoMsgNsName(m, true) << R"(>();
)";

    // set the values
    if(m.getReturns().size() > 1) {
        throw std::runtime_error("Methods with more than one return value are not yet supported");
    }

    for(const auto &a : m.getReturns()) {
        if(a.isBuiltinType()) {
            // primitive types are easy
            if(a.isPrimitiveType()) {
                os << "    reply." << SetterNameFor(a) << "(retVal);" << std::endl;
            }
            // strings and blobs have special handling to convert them to our desired types
            else {
                auto lowerName = a.getTypeName();
                std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);

                if(lowerName == "string") {
                    os << "    reply." << SetterNameFor(a) << "(retVal);" << std::endl;
                } else if(lowerName == "blob") {
                    os << "    reply." << SetterNameFor(a) << "(retVal.data(), retVal.size());"
                       << std::endl;
                } else {
                    throw std::runtime_error("Unknown non-primitive builtin type");
                }
            }
        }
        // non-builtin types aren't yet supported
        else {
            throw std::runtime_error("Serializing non-builtin type not yet supported");
        }
    }

    // serialize and send the message
    os << R"(    {
        auto rw = capnp::messageToFlatArray(replyBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        this->_doSendReply(hdr, rs);
    }
)";
}



/**
 * Writes the server method definition for the given method.
 */
void CodeGenerator::serverWriteMethodDef(std::ofstream &os, const Method &m,
        const std::string &namePrefix) {
    // return type
    if(m.isAsync()) {
        os << "void ";
    } else {
        auto &rets = m.getReturns();
        if(rets.empty()) {
            os << "void ";
        } else {
            // single argument?
            if(rets.size() == 1) {
                os << CppTypenameForArg(rets[0]) << ' ';
            }
            // more than one; we have to define a struct type
            else {
                throw std::runtime_error("multiple return types not yet implemented");
            }
        }
    }

    // its name and opening bracket
    const auto methodName = GetMethodName(m);
    os << namePrefix << methodName << '(';

    // any arguments
    const auto &params = m.getParameters();
    for(size_t i = 0; i < params.size(); i++) {
        const auto &a = params[i];

        // print its type (it's a const reference if it's non primitive)
        if(!a.isPrimitiveType()) {
            os << "const ";
        }
        os << CppTypenameForArg(a) << ' ';

        if(!a.isPrimitiveType()) {
            os << '&';
        }

        // its name and a comma if not last
        os << a.getName();

        if(i != params.size()-1) {
            os << ", ";
        }
    }

    // closing bracket
    os << ')';
}



/**
 * Returns the C++ type name for the given argument.
 */
std::string CodeGenerator::CppTypenameForArg(const Argument &a) {
    // look up built in types in the map
    if(a.isBuiltinType()) {
        // convert the argument to lowercase and lookup
        auto lowerName = a.getTypeName();
        std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);

        return gCppTypeNames.at(lowerName);
    }
    // otherwise, return its type as-is
    return a.getTypeName();
}

