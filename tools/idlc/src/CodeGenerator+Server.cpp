#include "CodeGenerator.h"
#include "CodeGenerator+CppHelpers.h"
#include "InterfaceDescription.h"

#include <algorithm>
#include <cctype>
#include <exception>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>

/**
 * Returns the name of the stub class for the server, given the interface name.
 */
static inline std::string GetClassName(const std::shared_ptr<InterfaceDescription> &id) {
    auto temp = id->getName();
    temp[0] = std::toupper(temp[0]);

    return temp + "Server";
}



/**
 * Generate the C++ server stub for the interface.
 *
 * This implements the concrete wire message (de)serialization for incoming requests, as well as
 * the replies thereto. The implementer then simply subclasses this base stub, and implements the
 * relevant abstract methods that actually implement the behavior of the interface.
 */
void CodeGenerator::generateServerStub() {
    auto fileNameH = this->outDir / ("Server_" + this->interface->getName() + ".hpp");
    auto fileNameCpp = this->outDir / ("Server_" + this->interface->getName() + ".cpp");
    std::cout << "    * Server stub: " << fileNameCpp.string() << ", " << fileNameH.string()
              << std::endl;

    // generate the header first
    std::ofstream header(fileNameH.string(), std::ofstream::trunc);
    this->serverWriteInfoBlock(header);
    header << R"(#pragma once

#include <string>
#include <cstddef>
#include <cstdint>
#include <memory>
#include <span>
#include <vector>
)" << std::endl;
    this->cppWriteIncludes(header);
    this->serverWriteHeader(header);

    // and then the implementation
    std::ofstream implementation(fileNameCpp.string(), std::ofstream::trunc);
    this->serverWriteInfoBlock(implementation);
    implementation << "#include \"" << fileNameH.filename().generic_string() << "\"" << std::endl
       << "#include \"" << this->protoFileName.filename().generic_string() << ".h\"" << std::endl
       << R"(
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <stdexcept>

#include <rpc/rt/RpcIoStream.hpp>

#include <capnp/message.h>
#include <capnp/serialize.h>

using namespace rpc;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
)";
    this->serverWriteImpl(implementation);
    implementation << "#pragma clang diagnostic pop" << std::endl;
}

/**
 * Write the generic info block comment for the server stub.
 */
void CodeGenerator::serverWriteInfoBlock(std::ofstream &os) {
    os << R"(/*
 * This RPC server stub was autogenerated by idlc. DO NOT EDIT!)" << std::endl
    << " * Generated from " << this->interface->getSourceFilename() << " for interface "
       << this->interface->getName() << " at " << this->creationTimestamp << std::endl
       << " *" << R"(
 * You should subclass this implementation and define the required abstract methods to complete
 * implementing the interface. Note that there are several helper methods available to simplify
 * this task, or to retrieve more information about the caller.
 *
 * See the full RPC documentation for more details.
)"
       << " */" << std::endl;
}



/**
 * Writes the header for the server stub.
 *
 * This consists of a large fixed portion to define types and internal functions and helpers, as
 * well as two variable portions: one, defining the abstract methods that the implementation shall
 * provide, and two, the implementation of the deserialization of method parameters, and then
 * serialization of its response.
 */
void CodeGenerator::serverWriteHeader(std::ofstream &os) {
    // set up the starting of the class
    const auto className = GetClassName(this->interface);

    os << "namespace rpc {" << std::endl << "namespace rt { class ServerRpcIoStream; }"
       << std::endl;
    os << "class " << className << " {";

    /*
     * Define the types, including the MessageHeader, which is the structure we expect to receive
     * from whatever input/output stream we're provided.
     */
    os << R"(
    struct MessageHeader {
        enum Flags: uint32_t {
            Request                     = (1 << 0),
            Response                    = (1 << 1),
        };

        uint64_t type;
        Flags flags;
        uint32_t tag;

        std::byte payload[];
    };
    static_assert(!(offsetof(MessageHeader, payload) % sizeof(uintptr_t)),
        "message header's payload is not word aligned");

    protected:
        using IoStream = rt::ServerRpcIoStream;
)";

    // public methods
    os << R"(
    public:
        )" << className << R"((const std::shared_ptr<IoStream> &stream);
        virtual ~)" << className << R"(();

        // Server's main loop; continuously read and handle messages.
        bool run(const bool block = true);
        // Process a single message.
        bool runOne(const bool block);
)";

    // abstract methods to implement
    os << R"(
    // These are methods the implementation provides to complete implementation of the interface
    protected:
)";
    for(const auto &m : this->interface->getMethods()) {
        os << "        virtual ";
        this->cppWriteMethodDef(os, m, "impl");
        os << " = 0;" << std::endl;
    }

    // implementation details
    os << R"(
    // Helpers provided to subclasses for implementation of interface methods
    protected:
        constexpr inline auto &getIo() {
            return this->io;
        }

    // Implementation details; pretend this does not exist
    private:
        std::shared_ptr<IoStream> io;
        size_t txBufSize{0};
        void *txBuf{nullptr};

        void _ensureTxBuf(const size_t);
        void _doSendReply(const MessageHeader &, const std::span<std::byte> &);

)";

    // autogenerated marshalling methods
    for(const auto &m : this->interface->getMethods()) {
        os << "        void _marshall" << GetMethodName(m)
           << "(const MessageHeader &, const std::span<std::byte> &payload)"
           << ";" << std::endl;
    }

    // close the class and namespace
    os << "}; // class " << className << std::endl
       << "} // namespace rpc" << std::endl;
}



/**
 * Writes the server stub implementation.
 */
void CodeGenerator::serverWriteImpl(std::ofstream &os) {
    const auto className = GetClassName(this->interface);
    os << "using Server = " << className << ';' << std::endl << std::endl;

    this->cppWriteCustomTypeHelpers(os);

    // constructors and run method
    os << R"(/**
 * Creates a new server instance, with the given IO stream.
 */
Server::)" << className << R"((const std::shared_ptr<IoStream> &stream) : io(stream) {
}

/**
 * Releases any allocated resources.
 */
Server::~)" << className << R"(() {
    if(this->txBuf) {
        free(this->txBuf);
    }
}

/**
 * Continuously processes messages until processing fails to receive another message.
 */
bool Server::run(const bool block) {
    bool cont;
    do {
        cont = this->runOne(block);
    } while(cont);
    return cont;
}

/**
 * Reads a single message from the RPC connection and attempts to process it.
 *
 * @throws If the received message is malformed.
 *
 * @return Whether a message was able to be received and processed.
 */
bool Server::runOne(const bool block) {
    // try to receive message
    std::span<std::byte> buf;
    if(!this->io->receive(buf, block)) return false;

    // get the message header and its payload
    if(buf.size() < sizeof(MessageHeader)) throw std::runtime_error("Received message too small");
    const auto hdr = reinterpret_cast<const MessageHeader *>(buf.data());

    const auto payload = buf.subspan(offsetof(MessageHeader, payload));

    // then invoke the appropriate marshalling function
    switch(hdr->type) {
)";

    for(const auto &m : this->interface->getMethods()) {
        os << "        case " << GetMethodIdConst(m) << ':' << std::endl
           << "            this->_marshall" << GetMethodName(m) << "(*hdr, payload);"
           << std::endl
           << "            break;" << std::endl;
    }

    os << R"(    }
    return true;
}

)";

    // built in helpers
    os << R"(

// Helper method to build and send a reply message
void Server::_doSendReply(const MessageHeader &inHdr, const std::span<std::byte> &payload) {
    const size_t len = sizeof(MessageHeader) + payload.size();
    this->_ensureTxBuf(len);

    auto hdr = reinterpret_cast<MessageHeader *>(this->txBuf);
    memset(hdr, 0, sizeof(*hdr));
    hdr->type = inHdr.type;
    hdr->flags = MessageHeader::Flags::Response;
    hdr->tag = inHdr.tag;

    memcpy(hdr->payload, payload.data(), payload.size());

    const std::span<std::byte> txBufSpan(reinterpret_cast<std::byte *>(this->txBuf), len);
    if(!this->io->reply(txBufSpan)) {
        throw std::runtime_error("Failed to send RPC reply");
    }
}

// Allocates an aligned transmit buffer of the given size
void Server::_ensureTxBuf(const size_t len) {
    if(len > this->txBufSize) {
        if(this->txBuf) {
            free(this->txBuf);
        }
        int err = posix_memalign(&this->txBuf, 16, len);
        if(err) {
            throw std::runtime_error("Failed to allocate RPC send buffer");
        }
        this->txBufSize = len;
    }
}
)";

    // implementations of marshalling methods
    for(const auto &m : this->interface->getMethods()) {
        this->serverWriteMarshallMethod(os, m);
    }
}

/**
 * Writes the implementation of the method to marshall the specified method call.
 */
void CodeGenerator::serverWriteMarshallMethod(std::ofstream &os, const Method &m) {
    // start method
    os << R"(/*
 * Autogenerated marshalling method for ')" << m.getName() << R"(' (id $)" << std::hex << m.getIdentifier() << R"()
 * Have )" << m.getParameters().size() << R"( parameter(s), )" << m.getReturns().size() << R"( return(s); method is )" << (m.isAsync() ? "async" : "sync") << R"(
 */
)"
       << "void Server::_marshall" << GetMethodName(m) << "(const MessageHeader &hdr, const std::span<std::byte> &payload) {";

    // deserialize the request
    os << R"(
    kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
            payload.size() / sizeof(capnp::word));
    capnp::FlatArrayMessageReader reader(message);
    auto request = reader.getRoot<)" << GetProtoMsgNsName(m, false) << R"(>();
)";

    for(const auto &a : m.getParameters()) {
        if(a.isBuiltinType()) {
            if(a.isPrimitiveType()) {
                os << "    const auto dec_" << a.getName() << " = request." << GetterNameFor(a)
                   << "();" << std::endl;
            }
            // strings and blobs have special handling to convert them to desired C++ types
            else {
                auto lowerName = a.getTypeName();
                std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);

                if(lowerName == "string") {
                    os << "    const std::string dec_" << a.getName() << "(request."
                       << GetterNameFor(a) << "());" << std::endl;
                } else if(lowerName == "blob") {
                    // this dropping the const ptr is absolutely disgusting
                    os << "    const auto dec_temp_" << a.getName() << " = request."
                        << GetterNameFor(a) << "();" << std::endl;
                    os << "    const std::span<std::byte> dec_" << a.getName()
                       << "(reinterpret_cast<std::byte *>(const_cast<unsigned char *>(dec_temp_"
                       << a.getName() << ".begin())), dec_temp_" << a.getName() << ".size());"
                       << std::endl;
                } else {
                    throw std::runtime_error("Unknown non-primitive builtin type");
                }
            }
        }
        // for custom types, invoke the appropriate deserializer method
        else {
            // get at the blob
            os << "    const auto dec_temp_" << a.getName() << " = request."
                << GetterNameFor(a) << "();" << std::endl;
            os << "    const std::span<std::byte> dec_raw_" << a.getName()
               << "(reinterpret_cast<std::byte *>(const_cast<unsigned char *>(dec_temp_"
               << a.getName() << ".begin())), dec_temp_" << a.getName() << ".size());"
               << std::endl;

            // then invoke the custom deserializer
            os << "    " << a.getTypeName() << " dec_" << a.getName() << ';' << std::endl
               << "    rpc::deserialize(dec_raw_" << a.getName() << ", dec_" << a.getName() << ");"
               << std::endl;
        }
    }

    // invoke implementation method
    os << std::endl;
    if(!m.isAsync() && !m.getReturns().empty()) {
        os << "    auto retVal = ";
    } else {
        os << "    ";
    }
    os << "this->impl" << GetMethodName(m) << '(';

    for(size_t i = 0; i < m.getParameters().size(); i++) {
        const auto &a = m.getParameters()[i];
        os << "dec_" << a.getName();

        if(i != m.getParameters().size()-1) {
            os << ", ";
        }
    }

    os << ");" << std::endl;

    // handle the reply
    if(!m.isAsync()) {
        this->serverWriteMarshallMethodReply(os, m);
    }

    // finish method
    os << '}' << std::endl;
}
/**
 * Writes marshalling code for sending the reply of the invoked method.
 *
 * XXX: This currently only handles the case of either zero or a single return value.
 */
void CodeGenerator::serverWriteMarshallMethodReply(std::ofstream &os, const Method &m) {
    // set up builder
    os << R"(
    capnp::MallocMessageBuilder replyBuilder;
    auto reply = replyBuilder.initRoot<)" << GetProtoMsgNsName(m, true) << R"(>();
)";

    // set the values
    if(m.getReturns().size() > 1) {
        throw std::runtime_error("Methods with more than one return value are not yet supported");
    }

    for(const auto &a : m.getReturns()) {
        if(a.isBuiltinType()) {
            // primitive types are easy
            if(a.isPrimitiveType()) {
                os << "    reply." << SetterNameFor(a) << "(retVal);" << std::endl;
            }
            // strings and blobs have special handling to convert them to our desired types
            else {
                auto lowerName = a.getTypeName();
                std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);

                if(lowerName == "string") {
                    os << "    reply." << SetterNameFor(a) << "(retVal);" << std::endl;
                } else if(lowerName == "blob") {
                    os << "    capnp::Data::Reader blobReader_" << a.getName()
                       << "(reinterpret_cast<const kj::byte *>(retVal.data()), retVal.size());"
                       << std::endl
                       << "    reply." << SetterNameFor(a) << "(blobReader_" << a.getName()
                       << ");" << std::endl;
                } else {
                    throw std::runtime_error("Unknown non-primitive builtin type");
                }
            }
        }
        // non-builtin types aren't yet supported
        else {
            throw std::runtime_error("Serializing non-builtin type not yet supported");
        }
    }

    // serialize and send the message
    os << R"(    {
        auto rw = capnp::messageToFlatArray(replyBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        this->_doSendReply(hdr, rs);
    }
)";
}



