#include "CodeGenerator.h"
#include "CodeGenerator+CppHelpers.h"
#include "InterfaceDescription.h"

#include <algorithm>
#include <exception>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>

/**
 * Returns the name of the stub class for the server, given the interface name.
 */
static inline std::string GetClassName(const std::shared_ptr<InterfaceDescription> &id) {
    auto temp = id->getName();
    temp[0] = std::toupper(temp[0]);

    return temp + "Client";
}



/**
 * Generate the C++ client stub for the interface.
 *
 * This is a full implementation that can be used directly by callers. The method calls on the
 * object are automatically converted to RPC messages, sent via the RPC stream, and the replies
 * decoded.
 */
void CodeGenerator::generateClientStub() {
    auto fileNameH = this->outDir / ("Client_" + this->interface->getName() + ".hpp");
    auto fileNameCpp = this->outDir / ("Client_" + this->interface->getName() + ".cpp");
    std::cout << "    * Client stub: " << fileNameCpp.string() << ", " << fileNameH.string()
              << std::endl;

    // generate the header first
    std::ofstream header(fileNameH.string(), std::ofstream::trunc);
    this->clientWriteInfoBlock(header);
    header << R"(#pragma once

#include <string>
#include <cstddef>
#include <cstdint>
#include <memory>
#include <span>
)" << std::endl;
    this->clientWriteHeader(header);

    // and then the implementation
    std::ofstream implementation(fileNameCpp.string(), std::ofstream::trunc);
    this->clientWriteInfoBlock(implementation);
    implementation << "#include \"" << fileNameH.filename().generic_string() << "\"" << std::endl
       << "#include \"" << this->protoFileName.filename().generic_string() << ".h\"" << std::endl
       << R"(
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <stdexcept>

#include <capnp/message.h>
#include <capnp/serialize.h>

using namespace rpc;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
)";
    this->clientWriteImpl(implementation);
    implementation << "#pragma clang diagnostic pop" << std::endl;
}

/**
 * Write the generic info block comment for the client stub.
 */
void CodeGenerator::clientWriteInfoBlock(std::ofstream &os) {
    os << R"(/*
 * This RPC client stub was autogenerated by idlc. DO NOT EDIT!)" << std::endl
    << " * Generated from " << this->interface->getSourceFilename() << " for interface "
       << this->interface->getName() << " at " << this->creationTimestamp << std::endl
       << " *" << R"(
 * You may use these generated stubs directly as the RPC interface, or you can subclass it to
 * override the behavior of the function calls, or to perform some preprocessing to the data as
 * needed before sending it.
 *
 * See the full RPC documentation for more details.
)"
       << " */" << std::endl;
}



/**
 * Writes the header for the client stub.
 *
 * Most of this interface is the same boilerplate as the server code contains, with the change
 * that there's only one set of call methods available.
 */
void CodeGenerator::clientWriteHeader(std::ofstream &os) {
    // set up the starting of the class
    const auto className = GetClassName(this->interface);

    os << "namespace rpc {" << std::endl;
    /**
     * Define the RPC stream type; this is an abstract interface that defines how the rest of the
     * server stub receives and sends messages.
     *
     * Note that the IO stream instance owns the receive message data, and that it must remain
     * valid for as long as the stream is active. The transmit buffer is required to only be
     * valid for the duration of the `send()` call.
     */
    os << R"(#ifndef __RPC_CLIENTRPCSTREAM_H
#define __RPC_CLIENTRPCSTREAM_H
class ClientRpcIoStream {
    public:
        virtual ~ClientRpcIoStream() = default;

        /// Send the serialized request to the remote connection
        virtual bool sendRequest(const std::span<std::byte> &buf) = 0;
        /// Receive a reply from the remote connection
        virtual bool receiveReply(std::span<std::byte> &outRxBuf) = 0;
};
#endif

)";

    os << "class " << className << " {";

    /*
     * Define the types, including the MessageHeader, which is the structure we expect to receive
     * from whatever input/output stream we're provided.
     */
    os << R"(
    struct MessageHeader {
        enum Flags: uint32_t {
            Request                     = (1 << 0),
            Response                    = (1 << 1),
        };

        uint64_t type;
        Flags flags;
        uint32_t tag;

        std::byte payload[];
    };
    static_assert(!(offsetof(MessageHeader, payload) % sizeof(uintptr_t)),
        "message header's payload is not word aligned");
    )";

    // public methods
    os << R"(
    public:
        )" << className << R"((const std::shared_ptr<ClientRpcIoStream> &stream);
        virtual ~)" << className << R"(();
    )";

    // actual RPC methods
    os << R"(
)";
    for(const auto &m : this->interface->getMethods()) {
        os << "        virtual ";
        this->cppWriteMethodDef(os, m);
        os << ';' << std::endl;
    }

    // implementation details
    os << R"(
    // Helpers provided to subclasses for implementation of interface methods
    protected:
        constexpr inline auto &getIo() {
            return this->io;
        }

    // Implementation details; pretend this does not exist
    private:
        std::shared_ptr<ClientRpcIoStream> io;
        size_t txBufSize{0};
        void *txBuf{nullptr};

        uint32_t nextTag{0};

        void _ensureTxBuf(const size_t);
        uint32_t _sendRequest(const uint64_t type, const std::span<std::byte> &);
)";

    // close the class and namespace
    os << "}; // class " << className << std::endl
       << "} // namespace rpc" << std::endl;
}




/**
 * Writes the implementation for the client stub.
 */
void CodeGenerator::clientWriteImpl(std::ofstream &os) {
    // define the constructor and destructors, as well as internal helpers
    const auto className = GetClassName(this->interface);
    os << "using Client = " << className << ';' << std::endl << std::endl;

    os << R"(/**
 * Creates a new client instance, with the given IO stream.
 */
Client::)" << className << R"((const std::shared_ptr<ClientRpcIoStream> &stream) : io(stream) {
}

/**
 * Shuts down the RPC client, releasing any allocated resources.
 */
Client::~)" << className << R"(() {
    if(this->txBuf) {
        free(this->txBuf);
    }
}
)";

os << R"(
/// Assemble a message with the given type.
uint32_t Client::_sendRequest(const uint64_t type, const std::span<std::byte> &payload) {
    const size_t len = sizeof(MessageHeader) + payload.size();
    this->_ensureTxBuf(len);

    const auto tag = __atomic_add_fetch(&this->nextTag, 1, __ATOMIC_RELAXED);
    auto hdr = reinterpret_cast<MessageHeader *>(this->txBuf);
    memset(hdr, 0, sizeof(*hdr));
    hdr->type = type;
    hdr->flags = MessageHeader::Flags::Request;
    hdr->tag = tag;

    memcpy(hdr->payload, payload.data(), payload.size());

    const std::span<std::byte> txBufSpan(reinterpret_cast<std::byte *>(this->txBuf), len);
    if(!this->io->sendRequest(txBufSpan)) {
        throw std::runtime_error("Failed to send RPC request");
    }

    return tag;
}

// Allocates an aligned transmit buffer of the given size
void Client::_ensureTxBuf(const size_t len) {
    if(len > this->txBufSize) {
        if(this->txBuf) {
            free(this->txBuf);
        }
        int err = posix_memalign(&this->txBuf, 16, len);
        if(err) {
            throw std::runtime_error("Failed to allocate RPC send buffer");
        }
        this->txBufSize = len;
    }
}

)";

    // write out the implementations for each of the calls
    for(const auto &m : this->interface->getMethods()) {
        this->clientWriteMarshallMethod(os, m);
    }
}

/**
 * Writes the implementation of the method to marshall the specified method call.
 */
void CodeGenerator::clientWriteMarshallMethod(std::ofstream &os, const Method &m) {
    // start method
    os << R"(/*
 * Autogenerated call method for ')" << m.getName() << R"(' (id $)" << std::hex << m.getIdentifier() << R"()
 * Have )" << m.getParameters().size() << R"( parameter(s), )" << m.getReturns().size() << R"( return(s); method is )" << (m.isAsync() ? "async" : "sync") << R"(
 */
)";
    this->cppWriteMethodDef(os, m, "Client::");
    os << " {";

    if(!m.isAsync()) {
        os << std::endl << "    uint32_t sentTag;";
    }

    // build up the request
    os << R"(
    {
        capnp::MallocMessageBuilder requestBuilder;
        auto request = requestBuilder.initRoot<)" << GetProtoMsgNsName(m, false) << R"(>();
)";

    for(const auto &a : m.getParameters()) {
        if(a.isBuiltinType()) {
            if(a.isPrimitiveType()) {
                os << "        request." << SetterNameFor(a) << "(" << a.getName() << ");" << std::endl;
            } else {
                auto lowerName = a.getTypeName();
                std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);

                if(lowerName == "string") {
                    os << "        request." << SetterNameFor(a) << "(" << a.getName() << ");" << std::endl;
                } else if(lowerName == "blob") {
                    os << "        capnp::Data::Reader blobReader_" << a.getName()
                       << "(reinterpret_cast<const kj::byte *>(" << a.getName() << ".data()), "
                       << a.getName() << ".size());" << std::endl
                       << "        request." << SetterNameFor(a) << "(blobReader_" << a.getName()
                       << ");" << std::endl;
                } else {
                    throw std::runtime_error("Unknown non-primitive builtin type");
                }
            }
        }
        else {
            throw std::runtime_error("Serializing non-builtin type not yet supported");
        }
    }

    // serialize and send
    os << R"(        auto rw = capnp::messageToFlatArray(requestBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        )" << (m.isAsync() ? "" : "sentTag = ") << R"(this->_sendRequest()" << GetMethodIdConst(m) 
<< R"(, rs);
    }
)";

    // read the response, if applicable
    if(!m.isAsync()) {
        this->clientWriteMarshallMethodReply(os, m);
    }

    // finish method
    os << '}' << std::endl;
}

/**
 * Writes marshalling code for receiving the reply of the invoked method.
 *
 * @note This will always result in a blocking call; there's no support in _not_ blocking on the
 * received message. Likewise, if any message tag other than the one we sent is received, we'll
 * abort.
 *
 * XXX: This currently only handles the case of either zero or a single return value.
 */
void CodeGenerator::clientWriteMarshallMethodReply(std::ofstream &os, const Method &m) {
    // first, receive a message and validate the received buffer
    os << R"(    {
        std::span<std::byte> buf;
        if(!this->io->receiveReply(buf)) throw std::runtime_error("Failed to receive RPC reply");
        if(buf.size() < sizeof(MessageHeader)) throw std::runtime_error("Received message too small");
        const auto hdr = reinterpret_cast<const MessageHeader *>(buf.data());
        if(hdr->tag != sentTag) throw std::runtime_error("Invalid tag in reply RPC packet");
        else if(hdr->type != )" << GetMethodIdConst(m) << R"() throw std::runtime_error("Invalid type in reply RPC packet");
        const auto payload = buf.subspan(offsetof(MessageHeader, payload));
)";

    // then deserialize it
    os << R"(
        kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
                payload.size() / sizeof(capnp::word));
        capnp::FlatArrayMessageReader reader(message);
        auto reply = reader.getRoot<)" << GetProtoMsgNsName(m, true) << R"(>();
)";

    // handle if there's reply arguments
    const auto &returns = m.getReturns();
    if(returns.size() == 1) {
        const auto &a = returns[0];
        os << "        return reply." << GetterNameFor(a) << "();";
    } else if(!returns.empty()) {
        throw std::runtime_error("Methods with more than one return value are not yet supported");
    }

    // end the method
    os << R"(
    }
)";
}
