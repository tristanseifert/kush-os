#include "CodeGenerator.h"
#include "InterfaceDescription.h"

#include <algorithm>
#include <exception>
#include <fstream>
#include <string>
#include <iomanip>
#include <iostream>

/**
 * Maps the names of lowercased IDL names to their size on the wire, in bytes. For the most part
 * this corresponds to the size of the types in C++ land.
 *
 * All binary types are represented as a pointer into the "payload" of the packet (the area after
 * all scalar types); each pointer takes up 8 bytes, a 4 byte offset and a 4 byte length.
 */
const std::unordered_map<std::string, size_t> CodeGenerator::gWireSizes{
    {"bool",   sizeof(bool)},
    {"int8",   sizeof(int8_t)},  {"int16",  sizeof(int16_t)}, 
    {"int32",  sizeof(int32_t)}, {"int64",  sizeof(int64_t)},
    {"uint8",  sizeof(uint8_t)}, {"uint16", sizeof(uint16_t)},
    {"uint32", sizeof(uint32_t)},{"uint64", sizeof(uint64_t)},
    {"float32",sizeof(float)},   {"float64",sizeof(double)},

    // pointer based types
    {"string", 2*sizeof(uint32_t)},  {"blob", sizeof(uint32_t)},

    // void types aren't actually encoded so they take up no space
    {"void", 0},
};

/// Maps the given IDL type to whether it is blob based (and encoded by a pointer) or not
const std::unordered_map<std::string, bool> CodeGenerator::gWireIsBlob{
    {"bool",   false},
    {"int8",   false}, {"int16",  false}, 
    {"int32",  false}, {"int64",  false},
    {"uint8",  false}, {"uint16", false},
    {"uint32", false}, {"uint64", false},
    {"float32",false}, {"float64",false},
    {"string", true},  {"blob",   true},
    {"void",   false},
};

/**
 * Convert string to lowercase
 */
static inline std::string LowerString(const std::string &in) {
    auto lower = in;
    std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
    return lower;
}

/**
 * Returns the name of the given interface's identifier in the Type enum.
 */
static inline std::string GetMessageIdEnumName(const InterfaceDescription::Method &m) {
    auto temp = m.getName();
    temp[0] = std::toupper(temp[0]);
    return temp;
}
/**
 * Returns the name of the given interface converted to the name of the request or response
 * structure.
 */
static inline std::string GetMessageStructName(const InterfaceDescription::Method &m,
        const bool isResponse) {
    auto temp = m.getName();
    temp[0] = std::toupper(temp[0]);
    return temp + (isResponse ? "Response" : "Request");
}


/**
 * Writes out definitions for each of the messages' request and reply structs.
 *
 * This includes the sizes and offsets of each of the fields within it in the wire format.
 */
void CodeGenerator::cppWriteStructs(std::ofstream &os) {
    // output info for each method
    os << R"(
/*
 * Definitions of serialization structures for messages and message replies. These use the
 * autogenerated stubs to convert to/from the wire format.
 */
namespace rpc::internals {
)";

    // write message types
    os << R"(/// Message ids for each of the RPC messages
enum class Type: uint64_t {
)";
    for(const auto &m : this->interface->getMethods()) {
        os << "    " << std::setw(48) << GetMessageIdEnumName(m) << " = 0x" << std::hex
           << m.getIdentifier() << std::dec << "ULL,\n";
    }
    os << "};" << std::endl;

    // then the structures
    for(const auto &method : this->interface->getMethods()) {
        this->serWriteMethod(os, method);
    }

os << R"(} // namespace rpc::internals

)";

    // write the associated serialization methods
    for(const auto &method : this->interface->getMethods()) {
        const auto requestName = GetMessageStructName(method, false);
        this->serWriteSerializers(os, method.getParameters(), requestName);
    }
}

/**
 * Writes out the request and optional reply structures for the given method.
 *
 * Note that we still generate structs even if the request/reply has no arguments; these will be
 * empty and it's the compiler's job to optimize calls to them away, since the serializers end up
 * as no-ops.
 */
void CodeGenerator::serWriteMethod(std::ofstream &os, const Method &m) {
    // start with the request structure
    os << R"(/**
 * Request structure for method ')" << m.getName() << R"('
 */
struct )" << GetMessageStructName(m, false) << " {" << std::endl;
    this->serWriteArgs(os, m.getParameters());
    os << "};" << std::endl;

    // if method is not async, write its reply structure
    if(!m.isAsync()) {
        const auto name = GetMessageStructName(m, true);

        os << R"(/**
 * Reply structure for method ')" << m.getName() << R"('
 */
struct )" << name << " {" << std::endl;
        this->serWriteArgs(os, m.getReturns());
        os << "};" << std::endl;
    }

    os << std::endl;
}

/**
 * Writes the arguments for the method out into the struct's argument form.
 *
 * Note that arguments are serialized in the order that they're specified in this arguments vector,
 * which is the declaration order.
 */
void CodeGenerator::serWriteArgs(std::ofstream &os, const std::vector<Argument> &args) {
    // write the actual storage
    for(const auto &a : args) {
        os << "    " << CppTypenameForArg(a, false) << " " << a.getName() << ";" << std::endl;
    }
    os << std::endl;

    /*
     * Write an array that contains the number of bytes that each element takes up on the wire. As
     * the first element is always at byte 0 of the message, we can implicitly use this to
     * calculate the offset of each element as we read an entire message.
     */
    size_t scalarBytes{0};
    os << "    constexpr static const size_t kElementSizes[" << args.size() << "] {" << std::endl
       << "    ";

    for(size_t i = 0; i < args.size(); i++) {
        const auto &a = args[i];
        size_t bytes;

        if(a.isBuiltinType()) {
            bytes = gWireSizes.at(LowerString(a.getTypeName()));
        } else {
            // non-builtin types are encoded as blobs
            bytes = 2*sizeof(uint32_t);
        }

        scalarBytes += bytes;

        os << std::setw(2) << bytes;

        if(i != (args.size() - 1)) {
            os << ", ";
        }
    }
    os << std::endl << "    };" << std::endl;
    os << "    constexpr static const size_t kScalarBytes{" << scalarBytes << "};" << std::endl;
}

/**
 * Writes the serialization methods for the message structure with the given arguments and type
 * name.
 */
void CodeGenerator::serWriteSerializers(std::ofstream &os, const std::vector<Argument> &args,
        const std::string &structName) {
    /**
     * Get the total number of bytes required for the message. This consists of the scalar bytes,
     * rounded up to the nearest 8 byte boundary. Then, it is followed by each of the blob datas
     * packed immediately after one another.
     *
     * The basic takeaway is that nothing is ever guaranteed to be aligned :D
     */
os << R"(size_t bytesFor(const rpc::internals::)" << structName << R"( &x) {
    using namespace rpc::internals;
    size_t len = (()" << structName << R"(::kScalarBytes + 8 - 1) / 8) * 8;
)";

    for(const auto &a : args) {
        // figure out if this is a blob
        const auto isBlob = a.isBuiltinType() ? gWireIsBlob.at(LowerString(a.getTypeName())) : true;
        if(!isBlob) continue;
        os << "    len += bytesFor(x." << a.getName() << ");" << std::endl;
    }

os << R"(
    return len;
}
)";
}

