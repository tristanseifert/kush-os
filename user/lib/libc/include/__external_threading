/*
 * Native threading implementation definition, used by the C++ library to provide C++ threads.
 */
#ifndef LIBC___THREADING_SUPPORT_H
#define LIBC___THREADING_SUPPORT_H

#include <chrono>
#include <cstdint>

#include <time.h>

_LIBCPP_BEGIN_NAMESPACE_STD

// use the system timespec type
typedef ::timespec __libcpp_timespec_t;

// calling convention for TLS destructors: we use the standard one
#define _LIBCPP_TLS_DESTRUCTOR_CC

// declare types
typedef void *__libcpp_mutex_t;
#define _LIBCPP_MUTEX_INITIALIZER 0

typedef void *__libcpp_recursive_mutex_t;
typedef void *__libcpp_condvar_t;
#define _LIBCPP_CONDVAR_INITIALIZER 0

typedef void *__libcpp_semaphore_t;
typedef void *__libcpp_exec_once_flag;
#define _LIBCPP_EXEC_ONCE_INITIALIZER 0

typedef uintptr_t __libcpp_thread_id;
#define _LIBCPP_NULL_THREAD 0U

typedef void *__libcpp_thread_t;
typedef uintptr_t __libcpp_tls_key;

// Mutex
int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m);

 
int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m);

 
bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m);

 
int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);


int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);

 
int __libcpp_mutex_lock(__libcpp_mutex_t *__m);

 
bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m);

 
int __libcpp_mutex_unlock(__libcpp_mutex_t *__m);


int __libcpp_mutex_destroy(__libcpp_mutex_t *__m);

// Condition variable

int __libcpp_condvar_signal(__libcpp_condvar_t* __cv);


int __libcpp_condvar_broadcast(__libcpp_condvar_t* __cv);

 
int __libcpp_condvar_wait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m);

 
int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               __libcpp_timespec_t *__ts);


int __libcpp_condvar_destroy(__libcpp_condvar_t* __cv);

#ifndef _LIBCPP_NO_NATIVE_SEMAPHORES

// Semaphore

bool __libcpp_semaphore_init(__libcpp_semaphore_t* __sem, int __init);


bool __libcpp_semaphore_destroy(__libcpp_semaphore_t* __sem);


bool __libcpp_semaphore_post(__libcpp_semaphore_t* __sem);


bool __libcpp_semaphore_wait(__libcpp_semaphore_t* __sem);


bool __libcpp_semaphore_wait_timed(__libcpp_semaphore_t* __sem, std::chrono::nanoseconds const& __ns);

#endif // _LIBCPP_NO_NATIVE_SEMAPHORES

// Execute once

int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
                          void (*init_routine)());

// Thread id

bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2);


bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2);

// Thread

bool __libcpp_thread_isnull(const __libcpp_thread_t *__t);


int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg);


__libcpp_thread_id __libcpp_thread_get_current_id();


__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);


int __libcpp_thread_join(__libcpp_thread_t *__t);


int __libcpp_thread_detach(__libcpp_thread_t *__t);


void __libcpp_thread_yield();


void __libcpp_thread_sleep_for(const std::chrono::nanoseconds& __ns);

// Thread local storage

int __libcpp_tls_create(__libcpp_tls_key* __key,
                        void(_LIBCPP_TLS_DESTRUCTOR_CC* __at_exit)(void*));


void *__libcpp_tls_get(__libcpp_tls_key __key);


int __libcpp_tls_set(__libcpp_tls_key __key, void *__p);

_LIBCPP_END_NAMESPACE_STD
#endif
