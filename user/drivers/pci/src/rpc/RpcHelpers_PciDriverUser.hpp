/*
 * This RPC serialization code was autogenerated by idlc (version 8a02fc5d). DO NOT EDIT!
 * Generated from UserClient.idl for interface PciDriverUser at 2021-06-26T17:21:36-0500
 *
 * The structs and methods within are used by the RPC system to serialize and deserialize the
 * arguments and return values on method calls. They work internally in the same way that encoding
 * custom types in RPC messages works.
 *
 * See the full RPC documentation for more details.
 */
#ifndef RPC_HELPERS_GENERATED_18072275200646215484
#define RPC_HELPERS_GENERATED_18072275200646215484

#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <string>
#include <span>
#include <string_view>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"

#define RPC_USER_TYPES_INCLUDES
#include <libpci/UserClientTypes.h>
#undef RPC_USER_TYPES_INCLUDES


namespace rpc {
/**
 * Method to handle a failure to deserialize a field; this will log the failure if built in debug
 * mode.
 */
static inline void HandleDecodeError(const char *typeName, const char *fieldName,
    const uintptr_t offset) {
    fprintf(stderr, "[RPC] Decode error for type %s, field %s at offset $%x\n", typeName, fieldName,
        offset);
}
static inline void HandleDecodeError(const char *typeName, const char *fieldName,
    const uintptr_t offset, const uint32_t blobDataOffset, const uint32_t blobSz) {
    fprintf(stderr, "[RPC] Decode error for type %s, field %s at offset $%x "
        "(blob offset $%x, $%x bytes)\n", typeName, fieldName, offset, blobDataOffset, blobSz);
}

/*
 * Serialization functions for various C++ built in types
 */
inline size_t bytesFor(const std::string &s) {
    return s.length();
}
inline bool serialize(std::span<std::byte> &out, const std::string &str) {
    if(str.empty()) return true;
    else if(out.size() < str.length()) return false;
    memcpy(out.data(), str.c_str(), str.length());
    return true;
}
inline bool deserialize(const std::span<std::byte> &in, std::string &outStr) {
    if(in.empty()) {
        outStr = "";
    } else {
        outStr = std::string(reinterpret_cast<const char *>(in.data()), in.size());
    }
    return true;
}

// XXX: this only works for POD types!
template<typename T>
inline size_t bytesFor(const std::vector<T> &s) {
    return s.size() * sizeof(T);
}
template<typename T>
inline bool serialize(std::span<std::byte> &out, const std::vector<T> &vec) {
    const size_t numBytes = vec.size() * sizeof(T);
    if(out.size() < numBytes) return false;
    memcpy(out.data(), vec.data(), out.size());
    return true;
}
template <typename T>
inline bool deserialize(const std::span<std::byte> &in, std::vector<T> &outVec) {
    const size_t elements = in.size() / sizeof(T);
    outVec.resize(elements);
    memcpy(outVec.data(), in.data(), in.size());
    return true;
}


/*
 * Definitions of serialization structures for messages and message replies. These use the
 * autogenerated stubs to convert to/from the wire format.
 */
namespace internals {
/// Message ids for each of the RPC messages
enum class Type: uint64_t {
                                         GetDeviceAt = 0xd5b64160331233f1ULL,
                                      ReadCfgSpace32 = 0x441bae330756a108ULL,
                                     WriteCfgSpace32 = 0xde92bb2db0b09f5dULL,
};
/**
 * Request structure for method 'GetDeviceAt'
 */
struct GetDeviceAtRequest {
    libpci::BusAddress address;

    constexpr static const size_t kElementSizes[1] {
     8
    };
    constexpr static const size_t kElementOffsets[1] {
     0
    };
    constexpr static const size_t kScalarBytes{8};
    constexpr static const size_t kBlobStartOffset{8};
};
/**
 * Reply structure for method 'GetDeviceAt'
 */
struct GetDeviceAtResponse {
    std::string path;

    constexpr static const size_t kElementSizes[1] {
     8
    };
    constexpr static const size_t kElementOffsets[1] {
     0
    };
    constexpr static const size_t kScalarBytes{8};
    constexpr static const size_t kBlobStartOffset{8};
};

/**
 * Request structure for method 'ReadCfgSpace32'
 */
struct ReadCfgSpace32Request {
    libpci::BusAddress address;
    uint16_t offset;

    constexpr static const size_t kElementSizes[2] {
     8,  2
    };
    constexpr static const size_t kElementOffsets[2] {
     0,  8
    };
    constexpr static const size_t kScalarBytes{10};
    constexpr static const size_t kBlobStartOffset{16};
};
/**
 * Reply structure for method 'ReadCfgSpace32'
 */
struct ReadCfgSpace32Response {
    uint32_t result;

    constexpr static const size_t kElementSizes[1] {
     4
    };
    constexpr static const size_t kElementOffsets[1] {
     0
    };
    constexpr static const size_t kScalarBytes{4};
    constexpr static const size_t kBlobStartOffset{8};
};

/**
 * Request structure for method 'WriteCfgSpace32'
 */
struct WriteCfgSpace32Request {
    libpci::BusAddress address;
    uint16_t offset;
    uint32_t value;

    constexpr static const size_t kElementSizes[3] {
     8,  2,  4
    };
    constexpr static const size_t kElementOffsets[3] {
     0,  8, 10
    };
    constexpr static const size_t kScalarBytes{14};
    constexpr static const size_t kBlobStartOffset{16};
};
/**
 * Reply structure for method 'WriteCfgSpace32'
 */
struct WriteCfgSpace32Response {

    constexpr static const size_t kElementSizes[0] {
    
    };
    constexpr static const size_t kElementOffsets[0] {
    
    };
    constexpr static const size_t kScalarBytes{0};
    constexpr static const size_t kBlobStartOffset{0};
};

} // namespace rpc::internals


inline size_t bytesFor(const internals::GetDeviceAtRequest &x) {
    using namespace internals;
    size_t len = GetDeviceAtRequest::kBlobStartOffset;
    len += bytesFor(x.address);

    return len;
}
inline bool serialize(std::span<std::byte> &out, const internals::GetDeviceAtRequest &x) {
    using namespace internals;
    uint32_t blobOff = GetDeviceAtRequest::kBlobStartOffset;
    {
        const auto off = GetDeviceAtRequest::kElementOffsets[0];
        const auto size = GetDeviceAtRequest::kElementSizes[0];
        auto range = out.subspan(off, size);
        const uint32_t blobSz = bytesFor(x.address);
        const uint32_t blobDataOffset = blobOff;
        auto blobRange = out.subspan(blobDataOffset, blobSz);
        if(!serialize(blobRange, x.address)) return false;
        blobOff += blobSz;
        memcpy(range.data(), &blobDataOffset, sizeof(blobDataOffset));
        memcpy(range.data()+sizeof(blobDataOffset), &blobSz, sizeof(blobSz));
    }

    return true;
}
inline bool deserialize(const std::span<std::byte> &in, internals::GetDeviceAtRequest &x) {
    using namespace internals;
    if(in.size() < GetDeviceAtRequest::kScalarBytes) return false;
    const auto blobRegion = in.subspan(GetDeviceAtRequest::kBlobStartOffset);
    {
        const auto off = GetDeviceAtRequest::kElementOffsets[0];
        const auto size = GetDeviceAtRequest::kElementSizes[0];
        auto range = in.subspan(off, size);
        if(range.empty() || range.size() != size) return false;
        uint32_t blobSz{0}, blobDataOffset{0};
        memcpy(&blobDataOffset, range.data(), sizeof(blobDataOffset));
        memcpy(&blobSz, range.data()+sizeof(blobDataOffset), sizeof(blobSz));
        auto blobRange = in.subspan(blobDataOffset, blobSz);
       if(!deserialize(blobRange, x.address)) {
            HandleDecodeError("GetDeviceAtRequest", "address", off, blobDataOffset, blobSz);
            return false;
        }
    }

    return true;
}

inline size_t bytesFor(const internals::GetDeviceAtResponse &x) {
    using namespace internals;
    size_t len = GetDeviceAtResponse::kBlobStartOffset;
    len += bytesFor(x.path);

    return len;
}
inline bool serialize(std::span<std::byte> &out, const internals::GetDeviceAtResponse &x) {
    using namespace internals;
    uint32_t blobOff = GetDeviceAtResponse::kBlobStartOffset;
    {
        const auto off = GetDeviceAtResponse::kElementOffsets[0];
        const auto size = GetDeviceAtResponse::kElementSizes[0];
        auto range = out.subspan(off, size);
        const uint32_t blobSz = bytesFor(x.path);
        const uint32_t blobDataOffset = blobOff;
        auto blobRange = out.subspan(blobDataOffset, blobSz);
        if(!serialize(blobRange, x.path)) return false;
        blobOff += blobSz;
        memcpy(range.data(), &blobDataOffset, sizeof(blobDataOffset));
        memcpy(range.data()+sizeof(blobDataOffset), &blobSz, sizeof(blobSz));
    }

    return true;
}
inline bool deserialize(const std::span<std::byte> &in, internals::GetDeviceAtResponse &x) {
    using namespace internals;
    if(in.size() < GetDeviceAtResponse::kScalarBytes) return false;
    const auto blobRegion = in.subspan(GetDeviceAtResponse::kBlobStartOffset);
    {
        const auto off = GetDeviceAtResponse::kElementOffsets[0];
        const auto size = GetDeviceAtResponse::kElementSizes[0];
        auto range = in.subspan(off, size);
        if(range.empty() || range.size() != size) return false;
        uint32_t blobSz{0}, blobDataOffset{0};
        memcpy(&blobDataOffset, range.data(), sizeof(blobDataOffset));
        memcpy(&blobSz, range.data()+sizeof(blobDataOffset), sizeof(blobSz));
        auto blobRange = in.subspan(blobDataOffset, blobSz);
       if(!deserialize(blobRange, x.path)) {
            HandleDecodeError("GetDeviceAtResponse", "path", off, blobDataOffset, blobSz);
            return false;
        }
    }

    return true;
}

inline size_t bytesFor(const internals::ReadCfgSpace32Request &x) {
    using namespace internals;
    size_t len = ReadCfgSpace32Request::kBlobStartOffset;
    len += bytesFor(x.address);

    return len;
}
inline bool serialize(std::span<std::byte> &out, const internals::ReadCfgSpace32Request &x) {
    using namespace internals;
    uint32_t blobOff = ReadCfgSpace32Request::kBlobStartOffset;
    {
        const auto off = ReadCfgSpace32Request::kElementOffsets[0];
        const auto size = ReadCfgSpace32Request::kElementSizes[0];
        auto range = out.subspan(off, size);
        const uint32_t blobSz = bytesFor(x.address);
        const uint32_t blobDataOffset = blobOff;
        auto blobRange = out.subspan(blobDataOffset, blobSz);
        if(!serialize(blobRange, x.address)) return false;
        blobOff += blobSz;
        memcpy(range.data(), &blobDataOffset, sizeof(blobDataOffset));
        memcpy(range.data()+sizeof(blobDataOffset), &blobSz, sizeof(blobSz));
    }
    {
        const auto off = ReadCfgSpace32Request::kElementOffsets[1];
        const auto size = ReadCfgSpace32Request::kElementSizes[1];
        auto range = out.subspan(off, size);
        memcpy(range.data(), &x.offset, range.size());
    }

    return true;
}
inline bool deserialize(const std::span<std::byte> &in, internals::ReadCfgSpace32Request &x) {
    using namespace internals;
    if(in.size() < ReadCfgSpace32Request::kScalarBytes) return false;
    const auto blobRegion = in.subspan(ReadCfgSpace32Request::kBlobStartOffset);
    {
        const auto off = ReadCfgSpace32Request::kElementOffsets[0];
        const auto size = ReadCfgSpace32Request::kElementSizes[0];
        auto range = in.subspan(off, size);
        if(range.empty() || range.size() != size) return false;
        uint32_t blobSz{0}, blobDataOffset{0};
        memcpy(&blobDataOffset, range.data(), sizeof(blobDataOffset));
        memcpy(&blobSz, range.data()+sizeof(blobDataOffset), sizeof(blobSz));
        auto blobRange = in.subspan(blobDataOffset, blobSz);
       if(!deserialize(blobRange, x.address)) {
            HandleDecodeError("ReadCfgSpace32Request", "address", off, blobDataOffset, blobSz);
            return false;
        }
    }
    {
        const auto off = ReadCfgSpace32Request::kElementOffsets[1];
        const auto size = ReadCfgSpace32Request::kElementSizes[1];
        auto range = in.subspan(off, size);
        if(range.empty() || range.size() != size) return false;
        memcpy(&x.offset, range.data(), range.size());
    }

    return true;
}

inline size_t bytesFor(const internals::ReadCfgSpace32Response &x) {
    using namespace internals;
    size_t len = ReadCfgSpace32Response::kBlobStartOffset;

    return len;
}
inline bool serialize(std::span<std::byte> &out, const internals::ReadCfgSpace32Response &x) {
    using namespace internals;
    uint32_t blobOff = ReadCfgSpace32Response::kBlobStartOffset;
    {
        const auto off = ReadCfgSpace32Response::kElementOffsets[0];
        const auto size = ReadCfgSpace32Response::kElementSizes[0];
        auto range = out.subspan(off, size);
        memcpy(range.data(), &x.result, range.size());
    }

    return true;
}
inline bool deserialize(const std::span<std::byte> &in, internals::ReadCfgSpace32Response &x) {
    using namespace internals;
    if(in.size() < ReadCfgSpace32Response::kScalarBytes) return false;
    const auto blobRegion = in.subspan(ReadCfgSpace32Response::kBlobStartOffset);
    {
        const auto off = ReadCfgSpace32Response::kElementOffsets[0];
        const auto size = ReadCfgSpace32Response::kElementSizes[0];
        auto range = in.subspan(off, size);
        if(range.empty() || range.size() != size) return false;
        memcpy(&x.result, range.data(), range.size());
    }

    return true;
}

inline size_t bytesFor(const internals::WriteCfgSpace32Request &x) {
    using namespace internals;
    size_t len = WriteCfgSpace32Request::kBlobStartOffset;
    len += bytesFor(x.address);

    return len;
}
inline bool serialize(std::span<std::byte> &out, const internals::WriteCfgSpace32Request &x) {
    using namespace internals;
    uint32_t blobOff = WriteCfgSpace32Request::kBlobStartOffset;
    {
        const auto off = WriteCfgSpace32Request::kElementOffsets[0];
        const auto size = WriteCfgSpace32Request::kElementSizes[0];
        auto range = out.subspan(off, size);
        const uint32_t blobSz = bytesFor(x.address);
        const uint32_t blobDataOffset = blobOff;
        auto blobRange = out.subspan(blobDataOffset, blobSz);
        if(!serialize(blobRange, x.address)) return false;
        blobOff += blobSz;
        memcpy(range.data(), &blobDataOffset, sizeof(blobDataOffset));
        memcpy(range.data()+sizeof(blobDataOffset), &blobSz, sizeof(blobSz));
    }
    {
        const auto off = WriteCfgSpace32Request::kElementOffsets[1];
        const auto size = WriteCfgSpace32Request::kElementSizes[1];
        auto range = out.subspan(off, size);
        memcpy(range.data(), &x.offset, range.size());
    }
    {
        const auto off = WriteCfgSpace32Request::kElementOffsets[2];
        const auto size = WriteCfgSpace32Request::kElementSizes[2];
        auto range = out.subspan(off, size);
        memcpy(range.data(), &x.value, range.size());
    }

    return true;
}
inline bool deserialize(const std::span<std::byte> &in, internals::WriteCfgSpace32Request &x) {
    using namespace internals;
    if(in.size() < WriteCfgSpace32Request::kScalarBytes) return false;
    const auto blobRegion = in.subspan(WriteCfgSpace32Request::kBlobStartOffset);
    {
        const auto off = WriteCfgSpace32Request::kElementOffsets[0];
        const auto size = WriteCfgSpace32Request::kElementSizes[0];
        auto range = in.subspan(off, size);
        if(range.empty() || range.size() != size) return false;
        uint32_t blobSz{0}, blobDataOffset{0};
        memcpy(&blobDataOffset, range.data(), sizeof(blobDataOffset));
        memcpy(&blobSz, range.data()+sizeof(blobDataOffset), sizeof(blobSz));
        auto blobRange = in.subspan(blobDataOffset, blobSz);
       if(!deserialize(blobRange, x.address)) {
            HandleDecodeError("WriteCfgSpace32Request", "address", off, blobDataOffset, blobSz);
            return false;
        }
    }
    {
        const auto off = WriteCfgSpace32Request::kElementOffsets[1];
        const auto size = WriteCfgSpace32Request::kElementSizes[1];
        auto range = in.subspan(off, size);
        if(range.empty() || range.size() != size) return false;
        memcpy(&x.offset, range.data(), range.size());
    }
    {
        const auto off = WriteCfgSpace32Request::kElementOffsets[2];
        const auto size = WriteCfgSpace32Request::kElementSizes[2];
        auto range = in.subspan(off, size);
        if(range.empty() || range.size() != size) return false;
        memcpy(&x.value, range.data(), range.size());
    }

    return true;
}

inline size_t bytesFor(const internals::WriteCfgSpace32Response &x) {
    using namespace internals;
    size_t len = WriteCfgSpace32Response::kBlobStartOffset;

    return len;
}
inline bool serialize(std::span<std::byte> &out, const internals::WriteCfgSpace32Response &x) {
    using namespace internals;
    uint32_t blobOff = WriteCfgSpace32Response::kBlobStartOffset;

    return true;
}
inline bool deserialize(const std::span<std::byte> &in, internals::WriteCfgSpace32Response &x) {
    using namespace internals;
    if(in.size() < WriteCfgSpace32Response::kScalarBytes) return false;
    const auto blobRegion = in.subspan(WriteCfgSpace32Response::kBlobStartOffset);

    return true;
}

}; // namespace rpc

#pragma clang diagnostic push

#endif // defined(RPC_HELPERS_GENERATED_18072275200646215484)
