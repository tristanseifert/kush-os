/*
 * This RPC client stub was autogenerated by idlc. DO NOT EDIT!
 * Generated from Driverman.idl for interface Driverman at 2021-06-17T13:19:53-0500
 *
 * You may use these generated stubs directly as the RPC interface, or you can subclass it to
 * override the behavior of the function calls, or to perform some preprocessing to the data as
 * needed before sending it.
 *
 * See the full RPC documentation for more details.
 */
#include "Client_Driverman.hpp"
#include "Driverman.capnp.h"

#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <stdexcept>

#include <capnp/message.h>
#include <capnp/serialize.h>

#include <rpc/rt/RpcIoStream.hpp>

using namespace rpc;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
using Client = DrivermanClient;

/**
 * Creates a new client instance, with the given IO stream.
 */
Client::DrivermanClient(const std::shared_ptr<IoStream> &stream) : io(stream) {
}

/**
 * Shuts down the RPC client, releasing any allocated resources.
 */
Client::~DrivermanClient() {
    if(this->txBuf) {
        free(this->txBuf);
    }
}

/// Assemble a message with the given type.
uint32_t Client::_sendRequest(const uint64_t type, const std::span<std::byte> &payload) {
    const size_t len = sizeof(MessageHeader) + payload.size();
    this->_ensureTxBuf(len);

    const auto tag = __atomic_add_fetch(&this->nextTag, 1, __ATOMIC_RELAXED);
    auto hdr = reinterpret_cast<MessageHeader *>(this->txBuf);
    memset(hdr, 0, sizeof(*hdr));
    hdr->type = type;
    hdr->flags = MessageHeader::Flags::Request;
    hdr->tag = tag;

    memcpy(hdr->payload, payload.data(), payload.size());

    const std::span<std::byte> txBufSpan(reinterpret_cast<std::byte *>(this->txBuf), len);
    if(!this->io->sendRequest(txBufSpan)) {
        throw std::runtime_error("Failed to send RPC request");
    }

    return tag;
}

// Allocates an aligned transmit buffer of the given size
void Client::_ensureTxBuf(const size_t len) {
    if(len > this->txBufSize) {
        if(this->txBuf) {
            free(this->txBuf);
        }
        int err = posix_memalign(&this->txBuf, 16, len);
        if(err) {
            throw std::runtime_error("Failed to allocate RPC send buffer");
        }
        this->txBufSize = len;
    }
}

/*
 * Autogenerated call method for 'addDevice' (id $e2cd5678129683fe)
 * Have 2 parameter(s), 1 return(s); method is sync
 */
std::string Client::AddDevice(const std::string &parent, const std::string &driverId) {
    uint32_t sentTag;
    {
        capnp::MallocMessageBuilder requestBuilder;
        auto request = requestBuilder.initRoot<rpc::_proto::messages::AddDeviceRequest>();
        request.setParent(parent);
        request.setDriverId(driverId);
        auto rw = capnp::messageToFlatArray(requestBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        sentTag = this->_sendRequest(rpc::_proto::messages::MESSAGE_ID_ADD_DEVICE, rs);
    }
    {
        std::span<std::byte> buf;
        if(!this->io->receiveReply(buf)) throw std::runtime_error("Failed to receive RPC reply");
        if(buf.size() < sizeof(MessageHeader)) throw std::runtime_error("Received message too small");
        const auto hdr = reinterpret_cast<const MessageHeader *>(buf.data());
        if(hdr->tag != sentTag) throw std::runtime_error("Invalid tag in reply RPC packet");
        else if(hdr->type != rpc::_proto::messages::MESSAGE_ID_ADD_DEVICE) throw std::runtime_error("Invalid type in reply RPC packet");
        const auto payload = buf.subspan(offsetof(MessageHeader, payload));

        kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
                payload.size() / sizeof(capnp::word));
        capnp::FlatArrayMessageReader reader(message);
        auto reply = reader.getRoot<rpc::_proto::messages::AddDeviceResponse>();
        return reply.getPath();
    }
}
/*
 * Autogenerated call method for 'setDeviceProperty' (id $9bd9cc73d64e045b)
 * Have 3 parameter(s), 0 return(s); method is sync
 */
void Client::SetDeviceProperty(const std::string &path, const std::string &key, const std::span<std::byte> &data) {
    uint32_t sentTag;
    {
        capnp::MallocMessageBuilder requestBuilder;
        auto request = requestBuilder.initRoot<rpc::_proto::messages::SetDevicePropertyRequest>();
        request.setPath(path);
        request.setKey(key);
        capnp::Data::Reader blobReader_data(reinterpret_cast<const kj::byte *>(data.data()), data.size());
        request.setData(blobReader_data);
        auto rw = capnp::messageToFlatArray(requestBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        sentTag = this->_sendRequest(rpc::_proto::messages::MESSAGE_ID_SET_DEVICE_PROPERTY, rs);
    }
    {
        std::span<std::byte> buf;
        if(!this->io->receiveReply(buf)) throw std::runtime_error("Failed to receive RPC reply");
        if(buf.size() < sizeof(MessageHeader)) throw std::runtime_error("Received message too small");
        const auto hdr = reinterpret_cast<const MessageHeader *>(buf.data());
        if(hdr->tag != sentTag) throw std::runtime_error("Invalid tag in reply RPC packet");
        else if(hdr->type != rpc::_proto::messages::MESSAGE_ID_SET_DEVICE_PROPERTY) throw std::runtime_error("Invalid type in reply RPC packet");
        const auto payload = buf.subspan(offsetof(MessageHeader, payload));

        kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
                payload.size() / sizeof(capnp::word));
        capnp::FlatArrayMessageReader reader(message);
        auto reply = reader.getRoot<rpc::_proto::messages::SetDevicePropertyResponse>();

    }
}
/*
 * Autogenerated call method for 'getDeviceProperty' (id $633375a0eade91a1)
 * Have 2 parameter(s), 1 return(s); method is sync
 */
std::vector<std::byte> Client::GetDeviceProperty(const std::string &path, const std::string &key) {
    uint32_t sentTag;
    {
        capnp::MallocMessageBuilder requestBuilder;
        auto request = requestBuilder.initRoot<rpc::_proto::messages::GetDevicePropertyRequest>();
        request.setPath(path);
        request.setKey(key);
        auto rw = capnp::messageToFlatArray(requestBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        sentTag = this->_sendRequest(rpc::_proto::messages::MESSAGE_ID_GET_DEVICE_PROPERTY, rs);
    }
    {
        std::span<std::byte> buf;
        if(!this->io->receiveReply(buf)) throw std::runtime_error("Failed to receive RPC reply");
        if(buf.size() < sizeof(MessageHeader)) throw std::runtime_error("Received message too small");
        const auto hdr = reinterpret_cast<const MessageHeader *>(buf.data());
        if(hdr->tag != sentTag) throw std::runtime_error("Invalid tag in reply RPC packet");
        else if(hdr->type != rpc::_proto::messages::MESSAGE_ID_GET_DEVICE_PROPERTY) throw std::runtime_error("Invalid type in reply RPC packet");
        const auto payload = buf.subspan(offsetof(MessageHeader, payload));

        kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
                payload.size() / sizeof(capnp::word));
        capnp::FlatArrayMessageReader reader(message);
        auto reply = reader.getRoot<rpc::_proto::messages::GetDevicePropertyResponse>();
        const auto retBlob = reply.getData();
        return std::vector<std::byte>(reinterpret_cast<const std::byte *>(retBlob.begin()),reinterpret_cast<const std::byte *>(retBlob.end()));

    }
}
/*
 * Autogenerated call method for 'StartDevice' (id $6a7cbf9e2efa75f0)
 * Have 1 parameter(s), 1 return(s); method is sync
 */
int32_t Client::StartDevice(const std::string &path) {
    uint32_t sentTag;
    {
        capnp::MallocMessageBuilder requestBuilder;
        auto request = requestBuilder.initRoot<rpc::_proto::messages::StartDeviceRequest>();
        request.setPath(path);
        auto rw = capnp::messageToFlatArray(requestBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        sentTag = this->_sendRequest(rpc::_proto::messages::MESSAGE_ID_START_DEVICE, rs);
    }
    {
        std::span<std::byte> buf;
        if(!this->io->receiveReply(buf)) throw std::runtime_error("Failed to receive RPC reply");
        if(buf.size() < sizeof(MessageHeader)) throw std::runtime_error("Received message too small");
        const auto hdr = reinterpret_cast<const MessageHeader *>(buf.data());
        if(hdr->tag != sentTag) throw std::runtime_error("Invalid tag in reply RPC packet");
        else if(hdr->type != rpc::_proto::messages::MESSAGE_ID_START_DEVICE) throw std::runtime_error("Invalid type in reply RPC packet");
        const auto payload = buf.subspan(offsetof(MessageHeader, payload));

        kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
                payload.size() / sizeof(capnp::word));
        capnp::FlatArrayMessageReader reader(message);
        auto reply = reader.getRoot<rpc::_proto::messages::StartDeviceResponse>();
        return reply.getStatus();
    }
}
/*
 * Autogenerated call method for 'StopDevice' (id $ee8b158787490a80)
 * Have 1 parameter(s), 1 return(s); method is sync
 */
int32_t Client::StopDevice(const std::string &path) {
    uint32_t sentTag;
    {
        capnp::MallocMessageBuilder requestBuilder;
        auto request = requestBuilder.initRoot<rpc::_proto::messages::StopDeviceRequest>();
        request.setPath(path);
        auto rw = capnp::messageToFlatArray(requestBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        sentTag = this->_sendRequest(rpc::_proto::messages::MESSAGE_ID_STOP_DEVICE, rs);
    }
    {
        std::span<std::byte> buf;
        if(!this->io->receiveReply(buf)) throw std::runtime_error("Failed to receive RPC reply");
        if(buf.size() < sizeof(MessageHeader)) throw std::runtime_error("Received message too small");
        const auto hdr = reinterpret_cast<const MessageHeader *>(buf.data());
        if(hdr->tag != sentTag) throw std::runtime_error("Invalid tag in reply RPC packet");
        else if(hdr->type != rpc::_proto::messages::MESSAGE_ID_STOP_DEVICE) throw std::runtime_error("Invalid type in reply RPC packet");
        const auto payload = buf.subspan(offsetof(MessageHeader, payload));

        kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
                payload.size() / sizeof(capnp::word));
        capnp::FlatArrayMessageReader reader(message);
        auto reply = reader.getRoot<rpc::_proto::messages::StopDeviceResponse>();
        return reply.getStatus();
    }
}
#pragma clang diagnostic pop
