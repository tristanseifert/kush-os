/*
 * This RPC server stub was autogenerated by idlc. DO NOT EDIT!
 * Generated from DiskDriver.idl for interface DiskDriver at 2021-06-21T02:00:07-0500
 *
 * You should subclass this implementation and define the required abstract methods to complete
 * implementing the interface. Note that there are several helper methods available to simplify
 * this task, or to retrieve more information about the caller.
 *
 * See the full RPC documentation for more details.
 */
#include "Server_DiskDriver.hpp"
#include "DiskDriver.capnp.h"

#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <stdexcept>

#include <rpc/rt/RpcIoStream.hpp>

#include <capnp/message.h>
#include <capnp/serialize.h>

using namespace rpc;

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
using Server = DiskDriverServer;

/**
 * Creates a new server instance, with the given IO stream.
 */
Server::DiskDriverServer(const std::shared_ptr<IoStream> &stream) : io(stream) {
}

/**
 * Releases any allocated resources.
 */
Server::~DiskDriverServer() {
    if(this->txBuf) {
        free(this->txBuf);
    }
}

/**
 * Continuously processes messages until processing fails to receive another message.
 */
bool Server::run(const bool block) {
    bool cont;
    do {
        cont = this->runOne(block);
    } while(cont);
    return cont;
}

/**
 * Reads a single message from the RPC connection and attempts to process it.
 *
 * @return Whether a message was able to be received and processed.
 */
bool Server::runOne(const bool block) {
    // try to receive message
    std::span<std::byte> buf;
    if(!this->io->receive(buf, block)) return false;

    // get the message header and its payload
    if(buf.size() < sizeof(MessageHeader)) {
        this->_HandleError(false, "Received message too small");
        return false;
    }
    const auto hdr = reinterpret_cast<const MessageHeader *>(buf.data());

    const auto payload = buf.subspan(offsetof(MessageHeader, payload));

    // then invoke the appropriate marshalling function
    switch(hdr->type) {
        case rpc::_proto::messages::MESSAGE_ID_GET_CAPACITY:
            this->_marshallGetCapacity(*hdr, payload);
            break;
        case rpc::_proto::messages::MESSAGE_ID_OPEN_SESSION:
            this->_marshallOpenSession(*hdr, payload);
            break;
        case rpc::_proto::messages::MESSAGE_ID_CLOSE_SESSION:
            this->_marshallCloseSession(*hdr, payload);
            break;
        case rpc::_proto::messages::MESSAGE_ID_CREATE_READ_BUFFER:
            this->_marshallCreateReadBuffer(*hdr, payload);
            break;
        case rpc::_proto::messages::MESSAGE_ID_CREATE_WRITE_BUFFER:
            this->_marshallCreateWriteBuffer(*hdr, payload);
            break;
        case rpc::_proto::messages::MESSAGE_ID_EXECUTE_COMMAND:
            this->_marshallExecuteCommand(*hdr, payload);
            break;
        case rpc::_proto::messages::MESSAGE_ID_RELEASE_READ_COMMAND:
            this->_marshallReleaseReadCommand(*hdr, payload);
            break;
        case rpc::_proto::messages::MESSAGE_ID_ALLOC_WRITE_MEMORY:
            this->_marshallAllocWriteMemory(*hdr, payload);
            break;
    }
    return true;
}



// Helper method to build and send a reply message
void Server::_doSendReply(const MessageHeader &inHdr, const std::span<std::byte> &payload) {
    const size_t len = sizeof(MessageHeader) + payload.size();
    this->_ensureTxBuf(len);

    auto hdr = reinterpret_cast<MessageHeader *>(this->txBuf);
    memset(hdr, 0, sizeof(*hdr));
    hdr->type = inHdr.type;
    hdr->flags = MessageHeader::Flags::Response;
    hdr->tag = inHdr.tag;

    memcpy(hdr->payload, payload.data(), payload.size());

    const std::span<std::byte> txBufSpan(reinterpret_cast<std::byte *>(this->txBuf), len);
    if(!this->io->reply(txBufSpan)) {
        this->_HandleError(false, "Failed to send RPC reply");
    }
}

// Allocates an aligned transmit buffer of the given size
void Server::_ensureTxBuf(const size_t len) {
    if(len > this->txBufSize) {
        if(this->txBuf) {
            free(this->txBuf);
        }
        int err = posix_memalign(&this->txBuf, 16, len);
        if(err) {
            this->_HandleError(true, "Failed to allocate RPC send buffer");
        }
        this->txBufSize = len;
    }
}

/**
 * Handles an error that occurred on the server connection. Implementations may override this
 * method if they want to use exceptions, for example.
 *
 * @param fatal If set, the error precludes further operation on this RPC connection
 * @param what Descriptive string for the error
 */
void Server::_HandleError(const bool fatal, const std::string_view &what) {
    fprintf(stderr, "[RPC] %s: Encountered %s RPC error: %s\n", kServiceName.data(),
        fatal ? "fatal" : "recoverable", what.data());
    if(fatal) exit(-1);
}
/*
 * Autogenerated marshalling method for 'GetCapacity' (id $91df49e5f38b0cb5)
 * Have 1 parameter(s), 3 return(s); method is sync
 */
void Server::_marshallGetCapacity(const MessageHeader &hdr, const std::span<std::byte> &payload) {
    kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
            payload.size() / sizeof(capnp::word));
    capnp::FlatArrayMessageReader reader(message);
    auto request = reader.getRoot<rpc::_proto::messages::GetCapacityRequest>();
    const auto dec_diskId = request.getDiskId();

    auto retVal = this->implGetCapacity(dec_diskId);

    capnp::MallocMessageBuilder replyBuilder;
    auto reply = replyBuilder.initRoot<rpc::_proto::messages::GetCapacityResponse>();
    reply.setStatus(retVal.status);
    reply.setSectorSize(retVal.sectorSize);
    reply.setNumSectors(retVal.numSectors);
    {
        auto rw = capnp::messageToFlatArray(replyBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        this->_doSendReply(hdr, rs);
    }
}
/*
 * Autogenerated marshalling method for 'OpenSession' (id $f4e1aa89aee2c5f)
 * Have 0 parameter(s), 5 return(s); method is sync
 */
void Server::_marshallOpenSession(const MessageHeader &hdr, const std::span<std::byte> &payload) {
    kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
            payload.size() / sizeof(capnp::word));
    capnp::FlatArrayMessageReader reader(message);
    auto request = reader.getRoot<rpc::_proto::messages::OpenSessionRequest>();

    auto retVal = this->implOpenSession();

    capnp::MallocMessageBuilder replyBuilder;
    auto reply = replyBuilder.initRoot<rpc::_proto::messages::OpenSessionResponse>();
    reply.setStatus(retVal.status);
    reply.setSessionToken(retVal.sessionToken);
    reply.setRegionHandle(retVal.regionHandle);
    reply.setRegionSize(retVal.regionSize);
    reply.setNumCommands(retVal.numCommands);
    {
        auto rw = capnp::messageToFlatArray(replyBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        this->_doSendReply(hdr, rs);
    }
}
/*
 * Autogenerated marshalling method for 'CloseSession' (id $bdac3777974760fb)
 * Have 1 parameter(s), 1 return(s); method is sync
 */
void Server::_marshallCloseSession(const MessageHeader &hdr, const std::span<std::byte> &payload) {
    kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
            payload.size() / sizeof(capnp::word));
    capnp::FlatArrayMessageReader reader(message);
    auto request = reader.getRoot<rpc::_proto::messages::CloseSessionRequest>();
    const auto dec_session = request.getSession();

    auto retVal = this->implCloseSession(dec_session);

    capnp::MallocMessageBuilder replyBuilder;
    auto reply = replyBuilder.initRoot<rpc::_proto::messages::CloseSessionResponse>();
    reply.setStatus(retVal);
    {
        auto rw = capnp::messageToFlatArray(replyBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        this->_doSendReply(hdr, rs);
    }
}
/*
 * Autogenerated marshalling method for 'CreateReadBuffer' (id $5c63169ecba56263)
 * Have 2 parameter(s), 3 return(s); method is sync
 */
void Server::_marshallCreateReadBuffer(const MessageHeader &hdr, const std::span<std::byte> &payload) {
    kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
            payload.size() / sizeof(capnp::word));
    capnp::FlatArrayMessageReader reader(message);
    auto request = reader.getRoot<rpc::_proto::messages::CreateReadBufferRequest>();
    const auto dec_session = request.getSession();
    const auto dec_requestedSize = request.getRequestedSize();

    auto retVal = this->implCreateReadBuffer(dec_session, dec_requestedSize);

    capnp::MallocMessageBuilder replyBuilder;
    auto reply = replyBuilder.initRoot<rpc::_proto::messages::CreateReadBufferResponse>();
    reply.setStatus(retVal.status);
    reply.setReadBufHandle(retVal.readBufHandle);
    reply.setReadBufMaxSize(retVal.readBufMaxSize);
    {
        auto rw = capnp::messageToFlatArray(replyBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        this->_doSendReply(hdr, rs);
    }
}
/*
 * Autogenerated marshalling method for 'CreateWriteBuffer' (id $2647106809f005fc)
 * Have 2 parameter(s), 3 return(s); method is sync
 */
void Server::_marshallCreateWriteBuffer(const MessageHeader &hdr, const std::span<std::byte> &payload) {
    kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
            payload.size() / sizeof(capnp::word));
    capnp::FlatArrayMessageReader reader(message);
    auto request = reader.getRoot<rpc::_proto::messages::CreateWriteBufferRequest>();
    const auto dec_session = request.getSession();
    const auto dec_requestedSize = request.getRequestedSize();

    auto retVal = this->implCreateWriteBuffer(dec_session, dec_requestedSize);

    capnp::MallocMessageBuilder replyBuilder;
    auto reply = replyBuilder.initRoot<rpc::_proto::messages::CreateWriteBufferResponse>();
    reply.setStatus(retVal.status);
    reply.setWriteBufHandle(retVal.writeBufHandle);
    reply.setWriteBufMaxSize(retVal.writeBufMaxSize);
    {
        auto rw = capnp::messageToFlatArray(replyBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        this->_doSendReply(hdr, rs);
    }
}
/*
 * Autogenerated marshalling method for 'ExecuteCommand' (id $aae5bbef0049e019)
 * Have 2 parameter(s), 0 return(s); method is async
 */
void Server::_marshallExecuteCommand(const MessageHeader &hdr, const std::span<std::byte> &payload) {
    kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
            payload.size() / sizeof(capnp::word));
    capnp::FlatArrayMessageReader reader(message);
    auto request = reader.getRoot<rpc::_proto::messages::ExecuteCommandRequest>();
    const auto dec_session = request.getSession();
    const auto dec_slot = request.getSlot();

    this->implExecuteCommand(dec_session, dec_slot);
}
/*
 * Autogenerated marshalling method for 'ReleaseReadCommand' (id $dcc360757768916a)
 * Have 2 parameter(s), 0 return(s); method is async
 */
void Server::_marshallReleaseReadCommand(const MessageHeader &hdr, const std::span<std::byte> &payload) {
    kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
            payload.size() / sizeof(capnp::word));
    capnp::FlatArrayMessageReader reader(message);
    auto request = reader.getRoot<rpc::_proto::messages::ReleaseReadCommandRequest>();
    const auto dec_session = request.getSession();
    const auto dec_slot = request.getSlot();

    this->implReleaseReadCommand(dec_session, dec_slot);
}
/*
 * Autogenerated marshalling method for 'AllocWriteMemory' (id $3dc1fae0d30f6af6)
 * Have 2 parameter(s), 3 return(s); method is sync
 */
void Server::_marshallAllocWriteMemory(const MessageHeader &hdr, const std::span<std::byte> &payload) {
    kj::ArrayPtr<const capnp::word> message(reinterpret_cast<const capnp::word *>(payload.data()),
            payload.size() / sizeof(capnp::word));
    capnp::FlatArrayMessageReader reader(message);
    auto request = reader.getRoot<rpc::_proto::messages::AllocWriteMemoryRequest>();
    const auto dec_session = request.getSession();
    const auto dec_bytesRequested = request.getBytesRequested();

    auto retVal = this->implAllocWriteMemory(dec_session, dec_bytesRequested);

    capnp::MallocMessageBuilder replyBuilder;
    auto reply = replyBuilder.initRoot<rpc::_proto::messages::AllocWriteMemoryResponse>();
    reply.setStatus(retVal.status);
    reply.setOffset(retVal.offset);
    reply.setBytesAllocated(retVal.bytesAllocated);
    {
        auto rw = capnp::messageToFlatArray(replyBuilder);
        auto rb = rw.asBytes();
        const std::span<std::byte> rs(reinterpret_cast<std::byte *>(rb.begin()), rb.size());
        this->_doSendReply(hdr, rs);
    }
}
#pragma clang diagnostic pop
